<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.5.2" />
<title>Flume Cookbook</title>
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revnumber, span#revdate, span#revremark {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #dddddd;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > div.content {
  white-space: pre;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}


@media print {
  div#footer-badges { display: none; }
}

div#toc {
  margin-bottom: 2.5em;
}

div#toctitle {
  color: #527bbd;
  font-family: sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock-content {
  white-space: pre;
}
div.verseblock-attribution {
  padding-top: 0.75em;
  text-align: left;
}

div.exampleblock-content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

/* IE6 sets dynamically generated links as visited. */
div#toc a:visited { color: blue; }
</style>
<script type="text/javascript">
/*<![CDATA[*/
window.onload = function(){asciidoc.footnotes(); asciidoc.toc(2);}
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  var cont = document.getElementById("content");
  var noteholder = document.getElementById("footnotes");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      // Use [\s\S] in place of . so multi-line matches work.
      // Because JavaScript has no s (dotall) regex flag.
      note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      spans[i].innerHTML =
        "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
        "' title='View footnote' class='footnote'>" + n + "</a>]";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
}

}
/*]]>*/
</script>
</head>
<body>
<div id="header">
<h1>Flume Cookbook</h1>
<span id="author">flume-dev@cloudera.org</span><br />
<span id="revnumber">version 0.9.1,</span>
<span id="revdate">September 10, 2010</span>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph"><p>Flume is a distributed, reliable, and available service for
efficiently collecting, aggregating, and moving large amounts of log
data.  Being highly configurable and very extensible means that there
are many options and thus many decisions that need to be made by an
operator.  This document is a "cookbook" with "recipes" for getting
Flume up and running quickly without being overwhelmed with all the
details.</p></div>
<div class="paragraph"><p>This document starts with some basic tips on experimenting with Flume
nodes, and then three stories about setting up agents for different
kinds of sources.  Finally we&#8217;ll do a quick setup for collectors and
how to troubleshoot distributed deployments.</p></div>
<div class="ulist"><ul>
<li>
<p>
Basic debugging with one-shot Flume nodes
</p>
</li>
<li>
<p>
Flume agents for Apache web server logging
</p>
</li>
<li>
<p>
Flume agents for syslog / syslog-ng logging
</p>
</li>
<li>
<p>
Flume agents for scribe logging


</p>
</li>
</ul></div>
</div>
<h2 id="_trying_out_flume_sources_and_sinks">Trying out Flume sources and sinks</h2>
<div class="sectionbody">
<div class="paragraph"><p>First this section will describe some basic tips for testing sources,
sinks and logical nodes.</p></div>
<h3 id="_testing_sources">Testing sources</h3><div style="clear:left"></div>
<div class="paragraph"><p>Testing sources is a straightforward process.  The <tt>flume</tt> script has
a <tt>dump</tt> command that allows you test data source configuration by
displaying data at the console.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>flume dump source</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content"><tt>source</tt> needs to be a single command line argument, so you may
need to add <em>quotes</em> or "quotes" to the argument if it has quotes or
parenthesis in them.  Using single quotes allow you to use unescaped
double quotes in the configuration argument. (ex: <tt>'text("/tmp/foo")'</tt>
or <tt>"text(\"/tmp/foo\")"</tt>).</td>
</tr></table>
</div>
<div class="paragraph"><p>Here are some simple examples to try:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ flume dump console
$ flume dump 'text("/path/to/file")'
$ flume dump 'file("/path/to/file")'
$ flume dump syslogTcp
$ flume dump 'syslogUdp(5140)'
$ flume dump 'tail("/path/to/file")'
$ flume dump 'tailDir("path/to/dir", "fileregex")'
$ flume dump 'rpcSource(12346)'</tt></pre>
</div></div>
<div class="paragraph"><p>Under the covers, this dump command is actually running the <tt>flume
node_nowatch</tt> command with some extra command line parameters.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>flume node_nowatch -1 -s -n dump -c "dump: $1 | console;"</tt></pre>
</div></div>
<div class="paragraph"><p>Here&#8217;s a summary of what the options mean.</p></div>
<div class="hdlist"><table>
<tr>
<td class="hdlist1">
<tt>-1</tt> 
<br />
</td>
<td class="hdlist2">
<p style="margin-top: 0;">
one shot execution.  This makes the node instance not use the
heartbeating mechanism to get a config.
</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<tt>-s</tt> 
<br />
</td>
<td class="hdlist2">
<p style="margin-top: 0;">
starts the Flume node without starting the node&#8217;s http status
web server.  If the status web server is started, a Flume node&#8217;s
status server will keep the process alive even if in one-shot mode.
If the -s flag is specified along with one-shot mode (-1), the Flume
node will exit after all logical nodes complete.
</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<tt>-c "node:src|snk;"</tt> 
<br />
</td>
<td class="hdlist2">
<p style="margin-top: 0;">
Starts the node with the given configuration
 definition.  NOTE: If not using -1, this will be invalidated
 upon the first heartbeat to the master.
</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<tt>-n node</tt> 
<br />
</td>
<td class="hdlist2">
<p style="margin-top: 0;">
gives the node the physical name node.
</p>
</td>
</tr>
</table></div>
<div class="paragraph"><p>You can get info on all of the Flume node commands by using this command:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ flume node -h</tt></pre>
</div></div>
<h3 id="_testing_sinks_and_decorators">Testing sinks and decorators</h3><div style="clear:left"></div>
<div class="paragraph"><p>Now that you can test sources, there is only one more step necessary
to test arbitrary sinks and decorators from the command line.  A sink
requires data to consume so some common sources used to generate test
data include synthetic datasets (<tt>asciisynth</tt>), the console
(<tt>console</tt>), or files (<tt>text</tt>).</p></div>
<div class="paragraph"><p>For example, you can use a synthetic source to generate 1000 events,
each of 100 "random" bytes data to the console. You could use a text
source to read a file like /etc/services, or you could use the console
as a source and interactively enter lines of text as events:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ flume node_nowatch -1 -s -n dump -c 'dump: asciisynth(1000,100) | console;'
$ flume node_nowatch -1 -s -n dump -c 'dump: text("/etc/services") | console;'
$ flume node_nowatch -1 -s -n dump -c 'dump: console | console;'</tt></pre>
</div></div>
<div class="paragraph"><p>You can also use decorators on the sinks you specify.  For example,
you could rate limit the amount of data that pushed from the source to
sink by inserting a delay decorator.  In this case, the <em>delay</em>
decorator waits 100ms before sending each synthesized event to the
console.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ flume node_nowatch -1 -s -n dump -c 'dump: asciisynth(1000,100) | { delay(100) =&gt; console};'</tt></pre>
</div></div>
<div class="paragraph"><p>Using the command line, you can send events via the direct best-effort
(BE) or disk-failover (DFO) agents.  The example below uses the
<tt>console</tt> source so you can interactively generate data to send in BE
and DFO mode to collectors.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Flume node_nowatch must be used when piping data in to a Flume
node&#8217;s console source.  The watchdog program does not forward stdin.</td>
</tr></table>
</div>
<div class="listingblock">
<div class="content">
<pre><tt>$ flume node_nowatch -1 -s -n dump -c 'dump: console | agentBESink("collectorHost");'
$ flume node_nowatch -1 -s -n dump -c 'dump: console | agentDFOSink("collectorHost");'</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">Since these nodes are executed with configurations entered at
the command line and never contact the master, they cannot use the
automatic chains or logical node translations.  Currently, the
acknowledgements used in E2E mode go through the master piggy-backed
on node-to-master heartbeats.  Since this mode does not heartbeat, E2E
mode should not be used.</td>
</tr></table>
</div>
<div class="paragraph"><p>Console sources are useful because we can pipe data into Flume
directly.  The next example pipes data from a program into Flume which
then delivers it.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ &lt;external process&gt; | flume node_nowatch -1 -s -n foo -c 'foo:console|agentBESink("collector");'</tt></pre>
</div></div>
<div class="paragraph"><p>Ideally, you could write data to a named pipe and just have Flume read
data from a named pipe using <tt>text</tt> or <tt>tail</tt>.  Unfortunately, this
version of Flume&#8217;s <tt>text</tt> and <tt>tail</tt> are not currently compatible with
named pipes in a Linux environment.  However, you could pipe data to a
Flume node listening on the stdin console:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ tail -f namedpipe | flume node_nowatch -1 -s -n foo -c 'foo:console|agentBESink;'</tt></pre>
</div></div>
<div class="paragraph"><p>Or you can use the exec source to get its output data:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ flume node_nowatch -1 -s -n bar -c 'bar:exec("cat pipe")|agentBESink;'</tt></pre>
</div></div>
<h3 id="_monitoring_nodes">Monitoring nodes</h3><div style="clear:left"></div>
<div class="paragraph"><p>While outputting data to a console or to a logfile is an effective way
to verify data transmission, Flume nodes provide a way to monitor the
state of sources and sinks.  This can be done by looking at the node&#8217;s
report page.  By default, you can navigate your web browser to the
nodes TCP 35862 port.  (<a href="http://node:35862/">http://node:35862/</a>)</p></div>
<div class="paragraph"><p>This page shows counter information about all of the logical nodes on
the physical node as well as some basic machine metric information.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">If you have multiple physical nodes on a single machine, there
may be a port conflict.  If you have the auto-find port option on
(<tt>flume.node.http.autofindport</tt>), the physical node will increment the
port number until it finds a free port it can bind to.</td>
</tr></table>
</div>
</div>
<h2 id="_using_flume_agents_for_apache_2_x_web_server_logging">Using Flume Agents for Apache 2.x Web Server Logging</h2>
<div class="sectionbody">
<div class="paragraph"><p>To connect Flume to Apache 2.x servers, you will need to</p></div>
<div class="paragraph"><p># Configure web log file permissions</p></div>
<div class="paragraph"><p># Tail the web logs or use piped logs to enable Flume to get data from
  the web server.</p></div>
<div class="paragraph"><p>This section will step through basic setup on default Ubuntu Lucid and
default CentOS 5.5 installations.  Then it will describe various ways
of integrating Flume.</p></div>
<h3 id="_if_you_are_using_centos_red_hat_apache_servers">If you are using CentOS / Red Hat Apache servers</h3><div style="clear:left"></div>
<div class="paragraph"><p>By default, CentOS&#8217;s Apache writes weblogs to files owned by <tt>root</tt>
and in group <tt>adm</tt> in 0644 (rw-r&#8212;r--) mode.  Flume is run as the
<tt>flume</tt> user, so the Flume node is able to read the logs.</p></div>
<div class="paragraph"><p>Apache on CentOS/Red Hat servers defaults to writing logs to two
files:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>/var/log/httpd/access_log
/var/log/httpd/error_log</tt></pre>
</div></div>
<div class="paragraph"><p>The simplest way to gather data from these files is to tail the files
by configuring Flume nodes to use Flume&#8217;s <tt>tail</tt> source:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>tail("/var/log/httpd/access_log")
tail("/var/log/httpd/error_log")</tt></pre>
</div></div>
<h3 id="_if_you_are_using_ubuntu_servers_apache_servers">If you are using Ubuntu servers Apache servers</h3><div style="clear:left"></div>
<div class="paragraph"><p>By default, Ubuntu writes weblogs to files owned by <tt>root</tt> and in
group <tt>adm</tt> in 0640 (rw-r-----) mode.  Flume is run as the <tt>flume</tt>
user and by default will <strong>not</strong> be able to tread the files.  One
approach to allow the <tt>flume</tt> user to read the files is to add it to
the <tt>adm</tt> group.</p></div>
<div class="paragraph"><p>Apache servers on Ubuntu defaults to writing logs to three files:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>/var/log/apache2/access.log
/var/log/apache2/error.log
/var/log/apache2/other_vhosts_access.log</tt></pre>
</div></div>
<div class="paragraph"><p>The simplest way to gather data from these files is by configuring
Flume nodes to use Flume&#8217;s <tt>tail</tt> source:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>tail("/var/log/apache2/access.log")
tail("/var/log/apache2/error.log")
tail("/var/log/apache2/other_vhosts_access.log")</tt></pre>
</div></div>
<h3 id="_getting_log_entries_from_piped_log_files">Getting log entries from Piped Log files</h3><div style="clear:left"></div>
<div class="paragraph"><p>The Apache 2.x&#8217;s documentation
(<a href="http://httpd.apache.org/docs/2.2/logs.html">http://httpd.apache.org/docs/2.2/logs.html</a>) describes using piped
logfile with the <tt>CustomLog</tt> directive.  Their example uses
<tt>rotatelogs</tt> to periodically write data to new files with a given
prefix.  Here are some example directives that could be in the
<tt>httpd.conf</tt>/<tt>apache2.conf</tt> file.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>LogFormat "%h %l %u %t \"%r\" %&gt;s %b" common
CustomLog "|/usr/sbin/rotatelogs /var/log/apache2/foo_access_log 3600" common</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">In Ubuntu Lucid these directives are in
<tt>/etc/apache2/sites-available/default</tt>. In CentOS 5.5, these
directives are in <tt>/etc/httpd/conf/httpd.conf</tt>.</td>
</tr></table>
</div>
<div class="paragraph"><p>These directives configure Apache to write log files in
<tt>/var/log/apache2/foo_access_log.xxxxx</tt> every hour (3600 seconds)
using the "common" log format.</p></div>
<div class="paragraph"><p>You can use Flume&#8217;s <tt>tailDir</tt> source to read all files without
modifing the Apache settings:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>tailDir("/var/log/apache2/", "foo_access_log.*")</tt></pre>
</div></div>
<div class="paragraph"><p>The first argument is the directory, and then the second is a regex
that should match against the file name.  <tt>tailDir</tt> will watch the dir
and tail all files that have matching file names.</p></div>
<h3 id="_using_piped_logs">Using piped logs</h3><div style="clear:left"></div>
<div class="paragraph"><p>Instead of writing data to disk and then having Flume read it, you can
have Flume ingest data directly from Apache.  To do so, modify the web
server&#8217;s parameters and use its piped log feature by adding some
directives to Apache&#8217;s configuration:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>CustomLog "|flume node_nowatch -1 -s -n apache -c \'apache:console|agentBESink(\"collector\");\'" common</tt></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt>CustomLog "|flume node_nowatch -1 -s -n apache -c \'apache:console|agentDFOSink(\"collector\");\'" common</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">By default, CentOS does not have the Java required by the
Flume node in user <tt>root</tt>'s path.  You can use <tt>alternatives</tt> to
create a managed symlink in <tt>/usr/bin/</tt> for the java executable.</td>
</tr></table>
</div>
<div class="paragraph"><p>Using piped logs can be more efficient, but is riskier because Flume
can deliver messages without saving on disk.  Doing this, however,
increases the probabiltiy of event loss.  From a security point of
view, this Flume node instance runs as Apache&#8217;s user which is often
<tt>root</tt> according to the Apache manual.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">You could configure the one-shot mode node to deliver data
directly to a collector.  This can only be done at the best effort or
disk-failover level.</td>
</tr></table>
</div>
<div class="paragraph"><p>The prior examples use Flume nodes in one-shot mode which runs without
contacting a master.  Unfortunately, it means that one-shot mode
cannot directly use the automatic chains or the end-to-end (E2E)
reliablity mode.  This is because the automatic chains are generated
by the master and because E2E mode currently delivers acknowledgements
through the master.</p></div>
<div class="paragraph"><p>However, you can have a one-shot Flume node deliver data to a Flume
local node daemon where the reliable E2E mode can be used.  In this
setup we would have the following Apache directive:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>CustomLog "|flume node_nowatch -1 -s -n apache -c \'apache:console|agentBESink(\"localhost\", 12345);\'" common</tt></pre>
</div></div>
<div class="paragraph"><p>Then you can have a Flume node setup to listen with the following
configuration:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>node : rpcSource(12345) | agentE2ESink("collector");</tt></pre>
</div></div>
<div class="paragraph"><p>Since this daemon node is connected to the master, it can use the
auto*Chains.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>node : rpcSource(12345) | autoE2EChain;</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">End-to-end mode attempts to ensure the deliver of the data that
enters the E2E sink.  In this one-shot-node to reliable-node scenario,
data is not safe it gets to the E2E sink.  However, since this is a
local connection, it should only fail when the machine or processes
fails.  The one-shot node can be set to disk failover (DFO) mode in
order to reduce the chance of message loss if the daemon node&#8217;s
configuration changes.</td>
</tr></table>
</div>
</div>
<h2 id="_flume_agents_for_syslog_data">Flume Agents for Syslog data</h2>
<div class="sectionbody">
<div class="paragraph"><p><tt>syslog</tt> is the standard unix single machine logging service.  Events
are generally emitted as lines with a time stamp, "facility" type,
priority, and message.  Syslog can be configured to send data to
remote destinations.  The default syslog remote delivery was
originally designed to provide best effort delivery service.  Today,
there are several more advanced syslog services that deliver messages
with improved reliability (TCP connections with memory buffering on
failure).  The reliability guarantees however are one hop and weaker
than Flume&#8217;s more reliable delivery mechanism.</p></div>
<div class="paragraph"><p>This section describes collecting syslog data using two methods.  The
first part describes a file tailing approach.  The latter parts
describe syslog system configuration guidance that enables directly
feeding Flume&#8217;s <tt>syslog*</tt> sources.</p></div>
<h3 id="_tailing_files">Tailing files</h3><div style="clear:left"></div>
<div class="paragraph"><p>The quickest way to record syslog messages is to tail syslog generated
log files.  These files generally live in <tt>/var/log</tt>.</p></div>
<div class="paragraph"><p>Some examples include:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>/var/log/auth.log
/var/log/messages
/var/log/syslog
/var/log/user.log</tt></pre>
</div></div>
<div class="paragraph"><p>These files could be tailed by Flume nodes with tail sources:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>tail("/var/log/auth.log")
tail("/var/log/messages")
tail("/var/log/syslog")
tail("/var/log/user.log")</tt></pre>
</div></div>
<div class="paragraph"><p>Depending on your system configuration, there may be permissions
issues when accessing these files from the Flume node process.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Red Hat/CentOS systems default to writing log files owned by
root, in group root, and with 0600 (-rw-------) permissions. Flume
could be run as root, but this is not advised because Flume can be
remotely configured to execute arbitrary programs.</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Ubuntu systems default to writing logs files owned by syslog, in
group adm, and with 0640 (-rw-r-----) permissions.  By adding the user
"flume" to group "adm", a Flume node running user "flume" should be
able to read the syslog generated files.</td>
</tr></table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">When tailing files, the time when the event is read is used as the
time stamp.</td>
</tr></table>
</div>
<h3 id="_delivering_syslog_events_via_sockets">Delivering Syslog events via sockets</h3><div style="clear:left"></div>
<div class="paragraph"><p>The original syslog listens to the <tt>/dev/log</tt> named pipe, and can be
configured to listen on UDP port
514. (<a href="http://tools.ietf.org/search/rfc5424">http://tools.ietf.org/search/rfc5424</a>). More advanced versions
(rsyslog, syslog-ng) can send and recieve over TCP and may do
in-memory queuing/buffering. For example, syslog-ng and rsyslog can
optionally use the default UDP port 514 or use TCP port 514 for better
recovery options.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">By default only superusers can listen on on UDP/TCP ports 514.
Unix systems usually only allow ports &lt;1024 to be bound by
superusers. While Flume can run as superuser, from a security stance
this is not advised.  The examples provide directions to route to the
user-bindable port 5140.</td>
</tr></table>
</div>
<div class="paragraph"><p>For debugging syslog configurations, you can just use <em>flume dump</em>
with syslog sources.  This command outputs received syslog data to the
console.  To test if syslog data is coming in to the proper port you
can run this command from the command line:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ flume dump 'syslogUdp(5140)'</tt></pre>
</div></div>
<div class="paragraph"><p>This will dump all incoming events to the console.</p></div>
<div class="paragraph"><p>If you are satisfied with your connection, you can have a Flume node
run on the machine configure its sink for the reliability level you
desire.</p></div>
<div class="paragraph"><p>Using a <tt>syslog*</tt> Flume source will save the entire line of event
data, use the timestamp found in the original data, extract a <tt>host</tt>,
and attempt to extract a service from the syslog line.  All of these
map to a Flume event&#8217;s fields except for <tt>service</tt> so this is added as
extra metadata field to each event (this is a convention with
syslog defined in RFC).</p></div>
<div class="paragraph"><p>So, a syslog entry whose body is this:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Sep 14 07:57:24 blitzwing dhclient: bound to 192.168.126.212 -- renewal in 710 seconds.</tt></pre>
</div></div>
<div class="paragraph"><p>will have the Flume event body:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>Sep 14 07:57:24 blitzwing dhclient: bound to 192.168.126.212 -- renewal in 710 seconds.</tt></pre>
</div></div>
<div class="paragraph"><p>The event will also translated the "Sep 14 07:57:24" date+time data so
that it will be bucketable.  Since this date does not have a year, it
assumes the current year and since it has no timezone it assumes the
local timezone.  The host field should be "blitzwing", and the
optional "service" metadata field will contain "dhclient".</p></div>
<h4 id="_configuring_tt_syslogd_tt">Configuring <tt>syslogd</tt></h4>
<div class="paragraph"><p>The original syslog is <tt>syslogd</tt>.  It is configured by an
<tt>/etc/syslog.conf</tt> file.  Its format is fairly simple.</p></div>
<div class="paragraph"><p>Syslog recieves messages and then sends to out to different facilities
that have associated names
(<a href="http://tools.ietf.org/search/rfc5424#section-6.2">http://tools.ietf.org/search/rfc5424#section-6.2</a>).</p></div>
<div class="paragraph"><p>The <tt>/etc/syslog.conf</tt> file essentially contains lists of facilities
and "actions".  These "actions" are destinations such as regular
files, but can also be named pipes, consoles, or remote machines.  One
can specify a remote machine by prefixing an <em>@</em> symbol in front the
destination host machine.  If no port is specified, events are sent
via UDP port 514.</p></div>
<div class="paragraph"><p>The example below specifies delivery to machine localhost on port
5140.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>user.*     @localhost:5140</tt></pre>
</div></div>
<div class="paragraph"><p>A Flume node daemon running on this machine would have a <tt>syslogUdp</tt>
source listening for new log data.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>host-syslog : syslogUdp(5140) | autoE2EChain ;</tt></pre>
</div></div>
<h4 id="_configuring_tt_rsyslog_tt">Configuring <tt>rsyslog</tt></h4>
<div class="paragraph"><p><tt>rsyslog</tt> is a more advanced drop-in replacement for syslog and the
default syslog system used by Ubuntu systems.  It supports basic
filtering, best effort delivery, and queuing for handling one-hop
downstream failures.</p></div>
<div class="paragraph"><p><tt>rsyslog</tt> actually extends the syslog configuration file format.
Similar to regular <tt>syslogd</tt> you can send data to a remote machine on
listening on UDP port 514 (standard syslog port).</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>*.*   @remotehost</tt></pre>
</div></div>
<div class="paragraph"><p>Moreover, <tt>rsyslog</tt> also allows you to use the more reliable TCP
protocol to send data to a remote host listening on TCP port 514.  In
<tt>rsyslog</tt> configurations, an <em>@@</em> prefix dictates the use of TCP.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>*.*  @@remotehost</tt></pre>
</div></div>
<div class="paragraph"><p>Similarly, you can also append a suffix port number to have it deliver
to a particular port.  In this example, events are delivered to
localhost TCP port 5140.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>*.*  @@localhost:5140</tt></pre>
</div></div>
<div class="paragraph"><p>Assuming you have a Flume node daemon running on the local host, you
can capture syslog data by adding a logical node with the following
configuration:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>host-syslog : syslogTcp(5140) | autoE2EChain ;</tt></pre>
</div></div>
<h4 id="_configuring_tt_syslog_ng_tt">Configuring <tt>syslog-ng</tt></h4>
<div class="paragraph"><p>Syslog-ng is another common replacement for the default syslog logging
system.  Syslog-ng has a different configuration file format but
essentially gives the operator the ability to send syslog data from
different facilities to different remote destinations.  TCP or UDP can
be used.</p></div>
<div class="paragraph"><p>Here is an example of modifications to a <tt>syslog-ng.conf</tt> (often found
in <tt>/etc/syslog-ng/</tt>) file.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>## set up logging to loghost (which is flume)
destination loghost {
        tcp("localhost" port(5140));
};

# send everything to loghost, too
log {
        source(src);
        destination(loghost);
};</tt></pre>
</div></div>
<div class="paragraph"><p>Assuming you have a Flume node daemon running on the local host, you
can capture syslog data by adding a logical node with the following
configuration:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>host-syslog : syslogTcp(5140) | autoE2EChain ;</tt></pre>
</div></div>
</div>
<h2 id="_logging_scribe_events_to_a_flume_agent">Logging Scribe Events to a Flume Agent</h2>
<div class="sectionbody">
<div class="paragraph"><p>Flume can emulate a downstream node for applications that log using
Scribe.  Scribe is Facebook&#8217;s open source log aggregation framework.
It has a simple API and uses Thrift as its core network transport
mechanism.  Flume uses the same Thrift IDL file and can listen for
data provided by Scribe sources.</p></div>
<div class="paragraph"><p>Scribe comes with an example application called <tt>scribe_cat</tt>.  It acts
like the unix <tt>cat</tt> program but sends data to a downstream host with a
specified "category".  Scribe by default uses TCP port 1463.</p></div>
<div class="paragraph"><p>You can configure a Flume node to listen for incoming Scribe traffic
by creating a logical node that uses the <tt>scribe</tt> source.  We can then
assign an arbitrary sink to the node.  In the example below, the
Scribe nodes receives events, send its events to both the console and
an automatically-assigned end-to-end agent which delivers the events
downstream to its collector pools.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>scribe: scribe | [console, autoE2EChain];</tt></pre>
</div></div>
<div class="paragraph"><p>Assuming that this node communicates with the master, and that the
node is on <tt>localhost</tt>, we can use the <tt>scribe_cat</tt> program to send
data to Flume.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ echo "foo" | scribe_cat localhost testcategory</tt></pre>
</div></div>
<div class="paragraph"><p>When the Scribe source accepts the Scribe events, it converts Scribe&#8217;s
category information into a new Flume event metadata entry, and then
delivers the event to its sinks.  Since Scribe does not include time
metadata, the timestamp of the created Flume event will be the arrival
time of the Scribe event.</p></div>
<div class="literalblock">
<div class="content">
<pre><tt>     ______
    / ___//_  ______  ____
   / /_/ / / / /    \/ __/
  / __/ / /_/ / / / / __/
 / / /_/\____/_/_/_/\__/
/_/ Distributed Log Collection.</tt></pre>
</div></div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Version 0.9.1<br />
Last updated 2010-11-08 15:11:25 PDT
</div>
</div>
</body>
</html>
